<!--

To run this demo, you need to replace 'YOUR_ACCESS_TOKEN' with an access token from ArcGIS that has the correct privileges.

To get started, sign up for a free ArcGIS Location Platform account or a free trial of ArcGIS Online and create developer credentials.

https://developers.arcgis.com/documentation/security-and-authentication/get-started/

-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1,user-scalable=no"
    />
    <title>
      Directions component with RouteLayer | Sample | ArcGIS Maps SDK for
      JavaScript
    </title>

    <!-- Load Calcite components from CDN -->
    <script
      type="module"
      src="https://js.arcgis.com/calcite-components/3.3.3/calcite.esm.js"
    ></script>

    <!-- Load the ArcGIS Maps SDK for JavaScript from CDN -->
    <script src="https://js.arcgis.com/4.34/"></script>

    <!-- Load Map components from CDN-->
    <script
      type="module"
      src="https://js.arcgis.com/4.34/map-components/"
    ></script>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      
      /* Custom styles for Calcite components */
      calcite-panel[slot="bottom-right"] {
        max-width: 300px;
        min-width: 220px;
      }

      calcite-card {
        margin:0px;
      }

      #controlsAccordion {
        width:30vw;
      }
    </style>
  </head>

  <body>
    <arcgis-map item-id="45b3b2fb35e94ab09381d0caa0da5946">
    <arcgis-zoom slot="top-right"></arcgis-zoom>
    <calcite-accordion slot="top-left" id="controlsAccordion" selection-mode="single">
        <calcite-accordion-item description="Routing Directions" heading="üêç Routing Directions" icon-start="embark" expanded>
          <arcgis-directions></arcgis-directions>
        </calcite-accordion-item>
        <calcite-accordion-item description="Routing Directions" heading="üéµ Directions2Music" icon-start="embark">
          <!-- Enhanced Music Generation Panel with Calcite Components -->
          <calcite-panel heading="üéµ Directions2Music">
            
            <!-- Directions Accordion -->
            <calcite-accordion id="directionsAccordion" icon-type="chevron">
              <calcite-accordion-item heading="Route Directions" expanded>
                <calcite-text-area 
                  id="directionsInput"
                  placeholder="Route directions will appear here automatically when you plan a route..."
                  rows="6"
                  resize="vertical"
                ></calcite-text-area>
              </calcite-accordion-item>
            </calcite-accordion>
            
            <!-- Controls Section -->
            <div style="padding:0.5rem;">
              <!-- Music Navigation and Generation Controls -->
              <div style="display: flex; gap: 0.5rem; align-items: center; margin: 0.5rem;">
                <!-- Navigation Buttons -->
                <div style="display: flex; gap: 0.25rem;">
                  <calcite-button 
                    id="backBtn" 
                    icon-start="chevron-left" 
                    scale="s" 
                    kind="neutral" 
                    appearance="outline"
                    disabled
                    title="Play previous music"
                  ></calcite-button>
                  <calcite-button 
                    id="forwardBtn" 
                    icon-start="chevron-right" 
                    scale="s" 
                    kind="neutral" 
                    appearance="outline"
                    disabled
                    title="Play next music"
                  ></calcite-button>
                </div>
                
                <!-- Generate Button -->
                <calcite-button 
                  id="generateBtn" 
                  icon-start="play" 
                  scale="m" 
                  style="flex: 1;"
                >
                  Generate Music
                </calcite-button>
              </div>
              
              <!-- Playlist Dropdown -->
              <div style="margin: 0 0.5rem 0.5rem 0.5rem;">
                <calcite-label>Playlist
                  <calcite-select 
                    id="playlistSelect" 
                    scale="s"
                    disabled
                  >
                    <calcite-option value="" label="No songs yet"></calcite-option>
                  </calcite-select>
                </calcite-label>
              </div>
              
              <!-- Checkboxes -->
              <div style="margin: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem;">
                <calcite-label layout="inline">
                  <calcite-checkbox id="dummyMode" checked></calcite-checkbox>
                  Fast Test Mode
                </calcite-label>
              </div>
            </div>
            
            <!-- Status Section -->
            <calcite-notice 
              id="statusSection" 
              kind="info" 
              scale="s" 
              style="display: none; margin: 0.5rem;"
            >
              <calcite-progress 
                id="progressBar" 
                type="indeterminate" 
                style="display: none; margin-top: 0.5rem;"
              ></calcite-progress>
            </calcite-notice>
            
            <!-- Style Info -->
            <calcite-card id="styleInfo" style="display: none; margin: 0.5rem;">
              <h4 slot="heading">Song Information</h4>
              <div id="styleDetails"></div>
            </calcite-card>
            
            <!-- Error Display -->
            <calcite-notice 
              id="errorMessage" 
              kind="danger" 
              scale="s" 
              style="display: none; margin:0.5rem;"
            >
              <div id="errorContent"></div>
            </calcite-notice>
            
            <!-- Audio Player -->
            <div id="audioSection" style="padding:0.5rem; display: none;">
              <audio controls id="audioPlayer" style="width: 100%; margin-top: 0.5rem;">
                <source id="audioSource" src="" type="audio/mpeg">
              </audio>
            </div>
            
          </calcite-panel>    
        </calcite-accordion-item>
    </arcgis-map>
    <script type="module">
      // Async job queue system for music generation
      const API_BASE = 'http://localhost:3001';
      let currentJobId = null;
      let pollInterval = null;
      
      // Music history navigation
      let musicHistory = []; // Array of {audioUrl, styleCard, timestamp, directions, routeGraphics} objects
      let currentMusicIndex = -1; // Current position in history (-1 = no music loaded)
      let currentRouteGraphics = null; // Current route graphics from directions component
      let routeGraphicsLayer = null; // GraphicsLayer for displaying historical routes
      let pendingRouteGraphics = null; // Route graphics waiting for map to be ready
      
      // DOM elements
      const directionsInput = document.getElementById('directionsInput');
      const generateBtn = document.getElementById('generateBtn');
      const backBtn = document.getElementById('backBtn');
      const forwardBtn = document.getElementById('forwardBtn');
      const playlistSelect = document.getElementById('playlistSelect');
      const dummyModeCheckbox = document.getElementById('dummyMode');
      const statusSection = document.getElementById('statusSection');
      const progressBar = document.getElementById('progressBar');
      const styleInfo = document.getElementById('styleInfo');
      const errorMessage = document.getElementById('errorMessage');
      const audioSection = document.getElementById('audioSection');
      const audioPlayer = document.getElementById('audioPlayer');
      const audioSource = document.getElementById('audioSource');

      // Show/hide UI elements  
      function showElement(element) { 
        if (element) element.style.display = 'block'; 
      }
      function hideElement(element) { 
        if (element) element.style.display = 'none'; 
      }

      function updateNavigationButtons() {
        // Back button: enabled if we can go to previous item in dropdown (lower index)
        const canGoBack = currentMusicIndex > 0;
        // Forward button: enabled if we can go to next item in dropdown (higher index)
        const canGoForward = currentMusicIndex < musicHistory.length - 1;
        
        backBtn.disabled = !canGoBack;
        forwardBtn.disabled = !canGoForward;
        
        // Update tooltips with track info
        if (musicHistory.length > 0) {
          const currentTrack = currentMusicIndex + 1;
          const totalTracks = musicHistory.length;
          
          backBtn.title = canGoBack ? 
            `Previous in list (${currentTrack - 1}/${totalTracks})` : 
            'No previous song';
            
          forwardBtn.title = canGoForward ? 
            `Next in list (${currentTrack + 1}/${totalTracks})` : 
            'No next song';
        } else {
          backBtn.title = 'No music history';
          forwardBtn.title = 'No music history';
        }
        
        // Update playlist dropdown
        updatePlaylistDropdown();
      }
      
      function updatePlaylistDropdown() {
        // Clear existing options
        playlistSelect.innerHTML = '';
        
        if (musicHistory.length === 0) {
          playlistSelect.disabled = true;
          const option = document.createElement('calcite-option');
          option.value = '';
          option.label = 'No songs yet';
          playlistSelect.appendChild(option);
        } else {
          playlistSelect.disabled = false;
          
          // Add options in reverse order (newest first)
          musicHistory.forEach((entry, index) => {
            const option = document.createElement('calcite-option');
            option.value = index.toString();
            const songTitle = entry.styleCard?.songTitle || `Track ${musicHistory.length - index}`;
            const genre = entry.styleCard?.genre || '';
            option.label = genre ? `${songTitle} (${genre})` : songTitle;
            
            // Mark current selection
            if (index === currentMusicIndex) {
              option.selected = true;
            }
            
            playlistSelect.appendChild(option);
          });
        }
      }

      function playMusicAtIndex(index) {
        if (index < 0 || index >= musicHistory.length) return;
        
        currentMusicIndex = index;
        const entry = musicHistory[index];
        
        // Update UI with historical data
        showStyleCard(entry.styleCard);
        showAudio(entry.audioUrl);
        
        // Update directions input to show what was used for this music
        directionsInput.value = entry.directions.join('\n');
        
        // Display historical route graphics
        if (entry.routeGraphics) {
          displayRouteGraphics(entry.routeGraphics);
        } else if (entry.routeGraphicsUrl) {
          // Load route graphics from separate file
          loadRouteGraphicsFromUrl(entry.routeGraphicsUrl, index);
        } else {
          clearRouteGraphics();
        }
        
        updateNavigationButtons();
      }

      // Load route graphics from separate file URL
      async function loadRouteGraphicsFromUrl(routeGraphicsUrl, musicIndex) {
        try {
          console.log(`üó∫Ô∏è Loading route graphics from: ${API_BASE}${routeGraphicsUrl}`);
          const response = await fetch(`${API_BASE}${routeGraphicsUrl}`);
          
          if (response.ok) {
            const routeGraphics = await response.json();
            console.log(`‚úÖ Loaded route graphics for track ${musicIndex}:`, routeGraphics);
            
            // Cache the loaded route graphics in the music history entry
            if (musicHistory[musicIndex]) {
              musicHistory[musicIndex].routeGraphics = routeGraphics;
            }
            
            // Display only if this is still the current track
            if (currentMusicIndex === musicIndex) {
              displayRouteGraphics(routeGraphics);
            }
          } else {
            console.warn(`‚ö†Ô∏è Failed to load route graphics: ${response.status} ${response.statusText}`);
            clearRouteGraphics();
          }
        } catch (error) {
          console.error(`üí• Error loading route graphics from ${routeGraphicsUrl}:`, error);
          clearRouteGraphics();
        }
      }

      function navigateBack() {
        if (currentMusicIndex > 0) {
          playMusicAtIndex(currentMusicIndex - 1);
        }
      }

      function navigateForward() {
        if (currentMusicIndex < musicHistory.length - 1) {
          playMusicAtIndex(currentMusicIndex + 1);
        }
      }

      // Route Graphics Management
      function captureRouteGraphics() {
        if (!directionsElement.lastRoute) return null;
        
        const route = directionsElement.lastRoute;
        return {
          directionLines: route.directionLines.items.map(item => ({
            geometry: {
              ...item.geometry.toJSON(), // Use toJSON() to properly serialize geometry
              type: "polyline" // Explicitly add geometry type for JSON serialization
            },
            symbol: {
              ...item.symbol,
              type: item.symbol.type || "simple-line", // Ensure symbol has type
              // Add default visual properties if missing
              color: item.symbol.color || [51, 122, 183, 0.8], // Blue color
              width: item.symbol.width || 3,
              style: item.symbol.style || "solid"
            }
          })),
          directionPoints: route.directionPoints.items.map(item => ({
            geometry: {
              ...item.geometry.toJSON(), // Use toJSON() to properly serialize geometry
              type: "point" // Explicitly add geometry type for JSON serialization
            },
            symbol: {
              ...item.symbol,
              type: item.symbol.type || "simple-marker", // Ensure symbol has type
              // Add default visual properties if missing
              color: item.symbol.color || [255, 255, 255],
              outline: item.symbol.outline || { color: [50, 50, 50], width: 1 },
              size: item.symbol.size || 8,
              style: item.symbol.style || "circle"
            }
          })),
          stops: route.stops.items.map(item => ({
            geometry: {
              ...item.geometry.toJSON(), // Use toJSON() to properly serialize geometry
              type: "point" // Explicitly add geometry type for JSON serialization
            },
            symbol: {
              ...item.symbol,
              type: item.symbol.type || "simple-marker", // Ensure symbol has type
              // Add default visual properties if missing
              color: item.symbol.color || [255, 0, 0],
              outline: item.symbol.outline || { color: [255, 255, 255], width: 2 },
              size: item.symbol.size || 12,
              style: item.symbol.style || "circle"
            }
          }))
        };
      }

      async function createRouteGraphicsLayer() {
        if (routeGraphicsLayer) return routeGraphicsLayer;
        
        // Wait for map to be ready
        if (!viewElement || !viewElement.map) {
          console.log('‚è≥ Map not ready yet, waiting...');
          return null;
        }
        
        const GraphicsLayer = await $arcgis.import("@arcgis/core/layers/GraphicsLayer.js");
        routeGraphicsLayer = new GraphicsLayer({
          id: "historical-routes",
          title: "Historical Routes"
        });
        
        // Add to map
        viewElement.map.add(routeGraphicsLayer);
        return routeGraphicsLayer;
      }

      async function displayRouteGraphics(routeGraphics) {
        if (!routeGraphics) return;
        
        // Check if map is ready
        if (!viewElement || !viewElement.map) {
          console.log('‚è≥ Map not ready, deferring route graphics display');
          // Store for later display when map is ready
          pendingRouteGraphics = routeGraphics;
          return;
        }
        
        const Graphic = await $arcgis.import("@arcgis/core/Graphic.js");
        const layer = await createRouteGraphicsLayer();
        
        if (!layer) {
          console.log('‚ùå Could not create route graphics layer');
          return;
        }
        
        // Clear existing graphics
        layer.removeAll();
        
        const graphicsArray = [];
        
        // Helper function to safely create graphics with proper type validation
        function createGraphicSafely(item, expectedGeometryType) {
          try {
            // Validate that geometry has the proper type
            if (!item.geometry || !item.geometry.type) {
              console.warn('‚ö†Ô∏è Missing geometry type, adding default:', expectedGeometryType);
              item.geometry = { ...item.geometry, type: expectedGeometryType };
            }
            
            // Add fallback symbology for old route graphics files
            let symbol = item.symbol || {};
            
            // For simple-line symbols without visual properties
            if (symbol.type === 'simple-line' && !symbol.color && !symbol.width) {
              symbol = {
                ...symbol,
                color: [0, 122, 255, 0.8], // Blue color
                width: 3,
                style: "solid"
              };
              console.log('üé® Added fallback line symbology');
            }
            
            // For simple-marker symbols without visual properties
            if (symbol.type === 'simple-marker' && !symbol.color && !symbol.size) {
              // Determine if this is a stop or direction point based on context
              const isStop = expectedGeometryType === 'point' && item.geometry;
              symbol = {
                ...symbol,
                color: isStop ? [255, 0, 0, 0.8] : [255, 255, 255, 0.9], // Red for stops, white for direction points
                size: isStop ? 12 : 8,
                outline: {
                  color: [0, 0, 0, 0.8],
                  width: 1
                }
              };
              console.log(`üé® Added fallback marker symbology for ${isStop ? 'stop' : 'direction point'}`);
            }
            
            // Create graphic - ArcGIS should now properly autocast
            const graphic = new Graphic({
              geometry: item.geometry,
              symbol: symbol
            });
            return graphic;
          } catch (error) {
            console.warn('‚ö†Ô∏è Failed to create graphic:', error, item);
            return null;
          }
        }
        
        // Add direction lines
        if (routeGraphics.directionLines) {
          routeGraphics.directionLines.forEach(item => {
            const graphic = createGraphicSafely(item, 'polyline');
            if (graphic) {
              layer.add(graphic);
              graphicsArray.push(graphic);
            }
          });
        }
        
        // Add direction points
        if (routeGraphics.directionPoints) {
          routeGraphics.directionPoints.forEach(item => {
            const graphic = createGraphicSafely(item, 'point');
            if (graphic) {
              layer.add(graphic);
              graphicsArray.push(graphic);
            }
          });
        }
        
        // Add stops
        if (routeGraphics.stops) {
          routeGraphics.stops.forEach(item => {
            const graphic = createGraphicSafely(item, 'point');
            if (graphic) {
              layer.add(graphic);
              graphicsArray.push(graphic);
            }
          });
        }
        
        console.log('üó∫Ô∏è Displayed route graphics:', {
          lines: routeGraphics.directionLines?.length || 0,
          points: routeGraphics.directionPoints?.length || 0,
          stops: routeGraphics.stops?.length || 0,
          totalGraphics: graphicsArray.length
        });

        // Navigate map to show the route graphics
        if (viewElement && graphicsArray.length > 0) {
          try {
            await viewElement.goTo(graphicsArray);
            console.log('üìç Map navigated to route graphics extent');
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not navigate to route graphics:', error);
            // Fallback: try to go to the first graphic's geometry
            try {
              if (graphicsArray[0] && graphicsArray[0].geometry) {
                await viewElement.goTo(graphicsArray[0].geometry);
                console.log('üìç Map navigated to first graphic');
              }
            } catch (fallbackError) {
              console.warn('‚ö†Ô∏è Fallback navigation also failed:', fallbackError);
            }
          }
        }
      }

      function clearRouteGraphics() {
        if (routeGraphicsLayer) {
          routeGraphicsLayer.removeAll();
        }
      }

      // Load existing music files from server
      async function loadMusicHistory() {
        console.log('üîÑ Starting to load music history...');
        
        // Try to load optional playlist configuration
        let playlistConfig = null;
        try {
          const configResponse = await fetch('./playlist.json');
          if (configResponse.ok) {
            playlistConfig = await configResponse.json();
            console.log('üìã Loaded playlist configuration:', playlistConfig);
          }
        } catch (error) {
          console.log('‚ÑπÔ∏è No playlist.json found, using default order');
        }
        
        try {
          console.log(`üì° Fetching from: ${API_BASE}/audio-files`);
          const response = await fetch(`${API_BASE}/audio-files`);
          console.log('üì¨ Response status:', response.status, response.statusText);
          
          const result = await response.json();
          console.log('üìÑ Raw response file names:', JSON.stringify(result.files.map(f => f.filename)));
          
          if (response.ok && result.files) {
            console.log(`üéµ Found ${result.files.length} files from server`);
            
            // Create a map of all available files for easy lookup
            const fileMap = new Map();
            result.files.forEach(file => {
              fileMap.set(file.filename, file);
            });
            
            // Process files based on playlist configuration
            const processedFiles = [];
            
            if (playlistConfig && playlistConfig.songs && Array.isArray(playlistConfig.songs)) {
              // Add songs in the specified order
              playlistConfig.songs.forEach(filename => {
                const file = fileMap.get(filename);
                if (file) {
                  processedFiles.push(file);
                  fileMap.delete(filename); // Remove from map to track what's been added
                  console.log(`üìå Added from playlist config: ${filename}`);
                } else {
                  console.warn(`‚ö†Ô∏è Playlist config references missing file: ${filename}`);
                }
              });
              
              // If playAll is true, add remaining files in their original order
              if (playlistConfig.playAll) {
                const remainingFiles = Array.from(fileMap.values());
                processedFiles.push(...remainingFiles);
                console.log(`üìö Added ${remainingFiles.length} remaining files (playAll: true)`);
              } else {
                console.log(`üö´ Skipped ${fileMap.size} files not in playlist (playAll: false)`);
              }
            } else {
              // No playlist config, use all files in original order
              processedFiles.push(...result.files);
              console.log('üìÇ Using all files in default order (no playlist config)');
            }
            
            // Convert processed files to music history entries with rich metadata
            processedFiles.forEach((file, index) => {
              console.log(`üìÄ Processing file ${index + 1}:`, file.filename);
              const musicEntry = {
                audioUrl: `${API_BASE}${file.url}`,
                styleCard: file.styleCard || {
                  songTitle: file.title || file.filename.replace('music_', '').replace('.mp3', ''),
                  genre: 'Generated Music',
                  artistName: 'AI Composer',
                  mood: ['Generated']
                },
                directions: file.directions || [`Generated music file: ${file.filename}`],
                timestamp: file.created,
                metadata: file.metadata, // Store full metadata for future use
                routeGraphics: file.routeGraphics || null, // Extract route graphics from separate file
                routeGraphicsUrl: file.routeGraphicsUrl || null // URL to route graphics file
              };
              musicHistory.push(musicEntry);
              console.log(`‚úÖ Added to history: ${musicEntry.styleCard.songTitle}`, {
                hasRouteGraphics: !!musicEntry.routeGraphics,
                routeGraphicsUrl: musicEntry.routeGraphicsUrl
              });
            });

            console.log(`üìö Total music history length: ${musicHistory.length}`);
            console.log(`üìã Music history:`, musicHistory);
            
            // Set current index to the most recent (first in array since they're sorted by date desc)
            if (musicHistory.length > 0) {
              console.log('‚ñ∂Ô∏è Playing most recent track at index 0');
              currentMusicIndex = 0;
              
              // For demo purposes, load dummy route graphics for the first track if no graphics exist
              if (!musicHistory[0].routeGraphics) {
                console.log('üìç Loading dummy route graphics for demo');
                try {
                  // Try to load from new organized location first
                  let dummyResponse;
                  try {
                    dummyResponse = await fetch(`${API_BASE}/route-graphics/dummyRouteGraphics.json`);
                  } catch (err) {
                    console.log('üìç Fallback to local dummy route graphics');
                    dummyResponse = await fetch('./dummyRouteGraphics.json');
                  }
                  const dummyGraphics = await dummyResponse.json();
                  musicHistory[0].routeGraphics = dummyGraphics;
                  console.log('‚úÖ Loaded dummy route graphics');
                } catch (err) {
                  console.log('‚ö†Ô∏è Could not load dummy route graphics:', err);
                }
              }
              
              playMusicAtIndex(0);
            } else {
              console.log('‚ùå No music in history to play');
            }
            
            updateNavigationButtons();
            console.log('‚úÖ Music history loading completed successfully');
          } else {
            console.log('‚ùå API response not OK or no files field:', response.status, result);
          }
        } catch (error) {
          console.error('üí• Failed to load music history:', error);
          // Continue without history - not a critical error
        }
      }

      // Update job status display using Calcite Notice
      function updateJobStatus(jobData) {
        const elapsed = jobData.elapsedTime ? Math.round(jobData.elapsedTime / 1000) : 0;
        
        // Update the status notice
        statusSection.kind = jobData.status === 'completed' ? 'success' : 
                            jobData.status === 'failed' ? 'danger' : 'info';
        statusSection.open = true;
        
        // Create status content
        const statusText = `Status: ${jobData.status.toUpperCase()}${elapsed > 0 ? ` ‚Ä¢ ${elapsed}s` : ''}`;
        const messageText = jobData.message || 'Processing...';
        
        // Update notice content
        statusSection.innerHTML = `
          <div slot="title">${statusText}</div>
          <div slot="message">${messageText}</div>
        `;
      }

      // Update progress - using Calcite Progress component
      function updateProgress(status, elapsedTime = 0) {
        if (progressBar) {
          if (status === 'pending') {
            progressBar.type = 'indeterminate';
            showElement(progressBar);
          } else if (status === 'processing') {
            // For processing, we can show determinate progress based on time
            const expectedDuration = dummyModeCheckbox.checked ? 10000 : 180000; // ms
            const progress = Math.min(90, (elapsedTime / expectedDuration) * 80 + 10);
            progressBar.type = 'determinate';
            progressBar.value = progress / 100; // Calcite expects 0-1 range
            showElement(progressBar);
          } else if (status === 'completed') {
            progressBar.type = 'determinate';
            progressBar.value = 1;
            setTimeout(() => hideElement(progressBar), 2000);
          } else if (status === 'failed') {
            hideElement(progressBar);
          }
        }
      }

      // Show style card information
      function showStyleCard(styleCardData) {
        if (!styleCardData || !styleInfo) return;
        
        // Update the style info card
        const heading = styleInfo.querySelector('h4[slot="heading"]');
        const details = styleInfo.querySelector('#styleDetails');
        
        if (heading && details) {
          // Show track position if we're browsing history
          const trackInfo = musicHistory.length > 0 ? 
            ` (${currentMusicIndex + 1}/${musicHistory.length})` : '';
            
          heading.textContent = `üé® ${styleCardData.songTitle}${trackInfo}`;
          details.textContent = `${styleCardData.genre} ‚Ä¢ ${styleCardData.artistName} ‚Ä¢ ${styleCardData.mood?.join(', ')}`;
        }
        
        showElement(styleInfo);
      }

      // Show audio player
      function showAudio(audioUrl) {
        if (audioSource && audioPlayer && audioSection) {
          audioSource.src = audioUrl;
          audioPlayer.load();
          showElement(audioSection);
          audioPlayer.play().catch(e => console.log('Audio autoplay prevented'));
        }
      }

      // Show error message using Calcite Notice
      function showError(error) {
        if (errorMessage) {
          errorMessage.kind = 'danger';
          errorMessage.open = true;
          errorMessage.innerHTML = `
            <div slot="title">Error</div>
            <div slot="message">${error}</div>
          `;
        }
      }

      // Start music generation job
      async function generateMusic() {
        const directions = directionsInput.value.trim().split('\n').filter(line => line.trim());
        
        if (directions.length === 0) {
          showError('Please enter some navigation directions or plan a route');
          return;
        }

        // Reset UI
        generateBtn.loading = true;
        generateBtn.disabled = true;
        
        // Hide previous results
        if (errorMessage) errorMessage.open = false;
        hideElement(styleInfo);
        hideElement(progressBar);
        hideElement(audioSection);

        try {
          const response = await fetch(`${API_BASE}/orchestrate`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              directions: directions,
              dummyMode: dummyModeCheckbox.checked,
              routeGraphics: currentRouteGraphics // Send captured route graphics
            })
          });

          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.error || 'Failed to start job');
          }

          currentJobId = result.jobId;
          // Keep button in loading state until job completes
          // generateBtn.loading = false;  // Don't reset loading here
          // generateBtn.disabled = false; // Keep disabled until job completes
          
          startPolling();

        } catch (error) {
          showError(error.message);
          generateBtn.loading = false;
          generateBtn.disabled = false;
        }
      }

      // Check job status
      async function checkJobStatus() {
        if (!currentJobId) return;

        try {
          const response = await fetch(`${API_BASE}/status/${currentJobId}`);
          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.error || 'Failed to check status');
          }

          updateJobStatus(result);
          updateProgress(result.status, result.elapsedTime);

          if (result.status === 'completed') {
            showStyleCard(result.styleCard);
            if (result.audioUrl) {
              const fullAudioUrl = `${API_BASE}${result.audioUrl}`;
              showAudio(fullAudioUrl);
              
              // Refresh complete music history from server to get all tracks
              console.log('üîÑ Refreshing music history after generation');
              musicHistory = []; // Clear current history
              await loadMusicHistory(); // Reload from server
              
              // Find the newly generated track and set it as current
              const newTrackIndex = musicHistory.findIndex(track => 
                track.audioUrl === fullAudioUrl
              );
              if (newTrackIndex !== -1) {
                currentMusicIndex = newTrackIndex;
                console.log(`üéØ Set current track index to ${newTrackIndex} for new track`);
              }
            }
            stopPolling();
            // Reset button state on completion
            generateBtn.loading = false;
            generateBtn.disabled = false;
          } else if (result.status === 'failed') {
            showError(result.error);
            stopPolling();
            // Reset button state on failure
            generateBtn.loading = false;
            generateBtn.disabled = false;
          }

        } catch (error) {
          showError(error.message);
          stopPolling();
          // Reset button state on error
          generateBtn.loading = false;
          generateBtn.disabled = false;
        }
      }

      // Start polling for job status
      function startPolling() {
        if (pollInterval) clearInterval(pollInterval);
        checkJobStatus(); // Check immediately
        pollInterval = setInterval(checkJobStatus, 2000); // Then every 2 seconds
      }

      // Stop polling
      function stopPolling() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }
      }

      // Event listeners
      generateBtn.addEventListener('click', generateMusic);
      backBtn.addEventListener('click', navigateBack);
      forwardBtn.addEventListener('click', navigateForward);
      playlistSelect.addEventListener('calciteSelectChange', (event) => {
        const selectedIndex = parseInt(event.target.value);
        if (!isNaN(selectedIndex) && selectedIndex >= 0) {
          playMusicAtIndex(selectedIndex);
        }
      });
      
      // Initialize navigation buttons on page load
      updateNavigationButtons();
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', stopPolling);

      // import RouteLayer module to load a RouteLayer from a portal item
      const RouteLayer = await $arcgis.import(
        "@arcgis/core/layers/RouteLayer.js"
      );
      // import esriConfig to set the API key
      const esriConfig = await $arcgis.import("@arcgis/core/config.js");

      // get access to the arcgis-map component element and arcgis-directions component
      const viewElement = document.querySelector("arcgis-map");
      const directionsElement = document.querySelector("arcgis-directions");

      // load application config (config.json) ‚Äî same-origin fetch
      // Using top-level await in this module script ensures config is
      // available before we configure esriConfig.
      const configResp = await fetch(new URL("./config.json", import.meta.url));
      if (!configResp.ok) {
        console.warn(
          "Failed to load config.json, falling back to placeholder token"
        );
      }
      const appConfig = configResp.ok ? await configResp.json() : {};

      // define the API key and define their scopes (only for directions component)
      // config.json can provide either `apiKey` or `token` fields.
      const token = appConfig.apiKey || appConfig.token || "%YOUR_ACCESS_TOKEN%";
      esriConfig.apiKeys.scopes = [
        {
          token: token,
          urls: [
            "https://geocode-api.arcgis.com/arcgis/rest/services/World/GeocodeServer",
            "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World",
          ],
        },
      ];

      // wait for the map and directions and routeLayer to be ready
      // and load the RouteLayer
      await viewElement.viewOnReady();
      await directionsElement.componentOnReady();
      directionsElement.searchProperties = {
        autoNavigate: true,
      };

      // Set padding to prevent controlsAccordion (30vw width) from covering route geometry
      // The 30vw translates to roughly 30% of viewport width in pixels
      const paddingLeft = Math.round(window.innerWidth * 0.3) + 20; // Add 20px buffer
      viewElement.view.padding = {
        left: paddingLeft,
        top: 0,
        right: 0,
        bottom: 0
      };
      console.log(`üó∫Ô∏è Set view padding - left: ${paddingLeft}px to prevent UI occlusion`);

      // Handle any pending route graphics now that map is ready
      if (pendingRouteGraphics) {
        console.log('üìç Map ready, displaying pending route graphics');
        displayRouteGraphics(pendingRouteGraphics);
        pendingRouteGraphics = null;
      }

      // Load music history after map is ready
      await loadMusicHistory();

      // Update padding when window resizes (since controlsAccordion width is 30vw)
      function updateViewPadding() {
        const paddingLeft = Math.round(window.innerWidth * 0.3) + 20; // Add 20px buffer
        if (viewElement.view) {
          viewElement.view.padding = {
            left: paddingLeft,
            top: 0,
            right: 0,
            bottom: 0
          };
          console.log(`üó∫Ô∏è Updated view padding - left: ${paddingLeft}px`);
        }
      }

      // Listen for window resize events to update padding
      window.addEventListener('resize', updateViewPadding);

      // Route event handler - populate directions textarea and capture route graphics
      directionsElement.addEventListener("arcgisPropertyChange", (event) => {
        if (event.detail.name === "lastRoute") {
          const route = directionsElement.lastRoute;
          if (route) {
            console.log("New route:", route);
            const directions = route.directionPoints.items.map((pt) => pt.displayText);
            console.log("Route directions:", directions);
            
            // Populate the directions textarea
            directionsInput.value = directions.join('\n');
            
            // Capture route graphics for later use
            currentRouteGraphics = captureRouteGraphics();
            console.log("üó∫Ô∏è Captured route graphics:", currentRouteGraphics);
            
            // Optional: Auto-generate if user wants (you can uncomment this line)
            // generateMusic();
          }
        }
      });

      // assign the RouteLayer to the Directions component
      // and add the RouteLayer to the map
      const routeLayer = new RouteLayer();
      directionsElement.layer = routeLayer;
      viewElement.map.add(routeLayer);
    </script>
  </body>
</html>
